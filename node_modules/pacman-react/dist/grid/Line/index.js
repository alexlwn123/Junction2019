function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React from 'react';
import PropTypes from 'prop-types';
import * as constants from '../../constants';

function getCornerArc(cornerArcRadius, clockwise, diffX, diffY) {
  return "a".concat(cornerArcRadius, ",").concat(cornerArcRadius, " 0 0 ").concat(clockwise >> 0, " ").concat(diffX, ",").concat(diffY);
}

var pmod = function pmod(num, base) {
  return (num % base + base) % base;
};

function getLinePart(_ref) {
  var radiusA = _ref.radiusA,
      radiusB = _ref.radiusB,
      path = _ref.path,
      lastDirection = _ref.lastDirection,
      distance = _ref.distance,
      direction = _ref.direction,
      index = _ref.index,
      end = _ref.end;
  var vertical = direction % 2;
  var horizontal = 1 - vertical;
  var reverse = Math.pow(-1, (direction < 2) >> 0);
  var polarity = Math.pow(-1, vertical);
  var vectorType = ['h', 'v'][vertical];

  if (index === 0) {
    var _vector = (radiusB - distance) * reverse * polarity;

    var _line = "".concat(vectorType).concat(_vector);

    return "".concat(path, " ").concat(_line);
  }

  var vector = (radiusA + radiusB * (!end >> 0) - distance) * reverse * polarity;
  var line = "".concat(vectorType).concat(vector);
  var cornerArcDiffX = radiusA * (Math.pow(-1, (lastDirection === constants.WEST) >> 0) * vertical - reverse * horizontal);
  var cornerArcDiffY = radiusA * (Math.pow(-1, (lastDirection === constants.NORTH) >> 0) * horizontal + reverse * vertical);
  var clockwise = (pmod(lastDirection - direction, 4) === 1) >> 0;
  var cornerArc = getCornerArc(radiusA, clockwise, cornerArcDiffX, cornerArcDiffY);
  return "".concat(path, " ").concat(cornerArc, " ").concat(line);
}

function getPoint(_ref2, gridSize) {
  var _ref3 = _slicedToArray(_ref2, 2),
      xValue = _ref3[0],
      yValue = _ref3[1];

  return [xValue * gridSize, (constants.BOARD_HEIGHT - yValue) * gridSize];
}

export default function Line(_ref4) {
  var gridSize = _ref4.gridSize,
      start = _ref4.start,
      parts = _ref4.parts,
      props = _objectWithoutProperties(_ref4, ["gridSize", "start", "parts"]);

  var startTransformed = getPoint(start, gridSize);
  var partRadius = parts.map(function (_ref5) {
    var radius = _ref5.radius;
    return gridSize / (radius || 3);
  });

  var _parts$map$reduce = parts.map(function (_ref6) {
    var distance = _ref6.distance,
        rest = _objectWithoutProperties(_ref6, ["distance"]);

    return _objectSpread({
      distance: distance * gridSize
    }, rest);
  }).reduce(function (_ref7, _ref8, index) {
    var path = _ref7.path,
        lastDirection = _ref7.lastDirection,
        lastRadius = _ref7.lastRadius;
    var distance = _ref8.distance,
        direction = _ref8.direction;
    return {
      path: getLinePart({
        radiusA: lastRadius,
        radiusB: partRadius[index],
        path: path,
        lastDirection: lastDirection,
        distance: distance,
        direction: direction,
        index: index,
        end: index === parts.length - 1
      }),
      lastDirection: direction,
      lastRadius: partRadius[index]
    };
  }, {
    path: "M".concat(startTransformed.join(','))
  }),
      pathString = _parts$map$reduce.path;

  var pathProps = {
    strokeWidth: props.strokeWidth,
    stroke: props.stroke,
    fill: props.fill
  };
  return React.createElement("path", _extends({
    d: pathString
  }, pathProps));
}
Line.propTypes = {
  strokeWidth: PropTypes.number,
  stroke: PropTypes.string,
  fill: PropTypes.string,
  gridSize: PropTypes.number.isRequired,
  start: PropTypes.array.isRequired,
  parts: PropTypes.array.isRequired
};