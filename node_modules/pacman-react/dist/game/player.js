function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { PLAYER_SPEED, EATING_TIME_SECONDS } from '../constants';
import { getNewPosition, getChangedVector, orderPolarity } from './movement';

function getEatenFood(food, player, newPosition) {
  var _orderPolarity = orderPolarity(player.direction),
      plane = _orderPolarity.plane,
      polarity = _orderPolarity.polarity;

  return food.findIndex(function (_ref) {
    var position = _ref.position,
        eaten = _ref.eaten;
    return !eaten && position[1 - plane] === player.position[1 - plane] && polarity * position[plane] >= polarity * player.position[plane] && polarity * position[plane] <= polarity * newPosition[plane];
  });
}

function getNewPlayerVector(player, time) {
  try {
    var _getNewPosition = getNewPosition(player.position, player.direction, PLAYER_SPEED, time),
        newPosition = _getNewPosition.newPosition,
        movedDistance = _getNewPosition.movedDistance;

    if (player.nextDirection !== player.direction) {
      var changedVector = getChangedVector(player.position, newPosition, player.direction, player.nextDirection, movedDistance);

      if (changedVector) {
        return {
          position: changedVector,
          direction: player.nextDirection
        };
      }
    }

    return {
      position: newPosition
    };
  } catch (err) {
    // wrapped
    return {};
  }
}

function eatMonsters(state) {
  return _objectSpread({}, state, {
    monsters: state.monsters.map(function (monster) {
      return _objectSpread({}, monster, {
        eatingTime: EATING_TIME_SECONDS
      });
    })
  });
}

export function animatePlayer(state, time) {
  var newVector = getNewPlayerVector(state.player, time);
  var eatenFoodIndex = getEatenFood(state.food, state.player, newVector.position);
  var food = state.food.slice();
  var scoreDelta = 0;

  if (eatenFoodIndex > -1) {
    food[eatenFoodIndex].eaten = true;
    scoreDelta = 1 + (food[eatenFoodIndex].big >> 0);
  }

  var eating = eatenFoodIndex > -1 && food[eatenFoodIndex].big;

  var nextState = _objectSpread({}, state, {
    score: state.score + scoreDelta,
    player: _objectSpread({}, state.player, {}, newVector),
    food: food
  });

  if (eating) {
    return eatMonsters(nextState);
  }

  return nextState;
}