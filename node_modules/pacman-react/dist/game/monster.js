function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import * as constants from '../constants';
import tracks from './tracks';
import { gridDistance, orderPolarity, getNewPosition, snapToTrack } from './movement';

function getAvailableVectors(_ref) {
  var newPosition = _ref.newPosition,
      plane = _ref.plane,
      trackTo = _ref.trackTo,
      distanceFromTrack = _ref.distanceFromTrack,
      movedDistance = _ref.movedDistance,
      availableOptions = _ref.availableOptions,
      player = _ref.player,
      eating = _ref.eating;
  return availableOptions.map(function (direction) {
    var _orderPolarity = orderPolarity(direction),
        optionPolarity = _orderPolarity.polarity,
        optionPlane = _orderPolarity.plane;

    var position = null;

    if (plane === optionPlane) {
      position = newPosition;
    } else {
      position = [];
      position[optionPlane] = newPosition[optionPlane] + Math.max(0, movedDistance - distanceFromTrack) * optionPolarity;
      position[1 - optionPlane] = trackTo;
    }

    var compare = [];
    compare[optionPlane] = newPosition[optionPlane] + optionPolarity;
    compare[1 - optionPlane] = position[1 - optionPlane];
    return {
      compare: compare,
      position: position,
      direction: direction
    };
  }).sort(function (_ref2, _ref3) {
    var posA = _ref2.compare;
    var posB = _ref3.compare;
    return Math.pow(-1, eating >> 0) * (gridDistance(posA, player.position) - gridDistance(posB, player.position));
  }).map(function (_ref4) {
    var direction = _ref4.direction,
        position = _ref4.position;
    return {
      direction: direction,
      position: position
    };
  });
}

function getNextMonsterHomePosition(newPosition, monster, player) {
  if (monster.direction === constants.EAST && monster.position[0] < constants.MONSTER_HOME_EXIT_COL && newPosition[0] >= constants.MONSTER_HOME_EXIT_COL || monster.direction === constants.WEST && monster.position[0] > constants.MONSTER_HOME_EXIT_COL && newPosition[0] <= constants.MONSTER_HOME_EXIT_COL) {
    return {
      position: [constants.MONSTER_HOME_EXIT_COL, newPosition[1]],
      direction: constants.NORTH
    };
  }

  if (monster.direction === constants.NORTH && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH] && newPosition[1] >= constants.MONSTER_HOME_RANGE[constants.NORTH]) {
    return {
      position: [newPosition[0], constants.MONSTER_HOME_RANGE[constants.NORTH]],
      direction: !monster.directionBias && monster.position[0] < player.position[0] ? constants.EAST : constants.WEST
    };
  }

  return {
    position: newPosition
  };
}

function getIsHome(monster) {
  return monster.position[0] > constants.MONSTER_HOME_RANGE[constants.WEST] && monster.position[0] < constants.MONSTER_HOME_RANGE[constants.EAST] && monster.position[1] > constants.MONSTER_HOME_RANGE[constants.SOUTH] && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH];
}

function getAvailableMonsterRoutes(_ref5) {
  var newPosition = _ref5.newPosition,
      collision = _ref5.collision,
      plane = _ref5.plane,
      trackTo = _ref5.trackTo,
      monster = _ref5.monster;
  var availableOptions = [];
  var distanceFromTrack = 0;

  if (trackTo !== -1 && tracks[1 - plane][trackTo]) {
    var passedTrack = tracks[1 - plane][trackTo].find(function (_ref6) {
      var _ref7 = _slicedToArray(_ref6, 2),
          start = _ref7[0],
          end = _ref7[1];

      return newPosition[1 - plane] >= start && newPosition[1 - plane] <= end;
    });
    var options = [null, null];

    if (passedTrack[0] < newPosition[1 - plane]) {
      options[0] = plane === 0 ? constants.SOUTH : constants.WEST;
    }

    if (passedTrack[1] > newPosition[1 - plane]) {
      options[1] = plane === 0 ? constants.NORTH : constants.EAST;
    }

    availableOptions = options.filter(function (item) {
      return item !== null;
    });
    distanceFromTrack = Math.abs(newPosition[plane] - trackTo);
  }

  if (!collision) {
    availableOptions.push(monster.direction);
  }

  return {
    availableOptions: availableOptions,
    distanceFromTrack: distanceFromTrack
  };
}

function getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player) {
  // determine where to move a monster if it has a decision to make
  var _orderPolarity2 = orderPolarity(monster.direction),
      order = _orderPolarity2.order,
      plane = _orderPolarity2.plane;

  var trackTo = snapToTrack(plane, order, newPosition, movedDistance);

  if (trackTo === -1 && collision) {
    throw new Error('Collided but nothing to track to');
  }

  var _getAvailableMonsterR = getAvailableMonsterRoutes({
    newPosition: newPosition,
    collision: collision,
    plane: plane,
    trackTo: trackTo,
    monster: monster
  }),
      availableOptions = _getAvailableMonsterR.availableOptions,
      distanceFromTrack = _getAvailableMonsterR.distanceFromTrack;

  if (!availableOptions.length) {
    // this happens when wrapping
    return {
      position: newPosition
    };
  }

  var vectors = getAvailableVectors({
    newPosition: newPosition,
    plane: plane,
    trackTo: trackTo,
    distanceFromTrack: distanceFromTrack,
    movedDistance: movedDistance,
    availableOptions: availableOptions,
    player: player,
    eating: monster.eatingTime > 0
  });
  var distanceFromPlayer = gridDistance(vectors[0].position, player.position);

  if (distanceFromPlayer < constants.PLAYER_RADIUS * 1.8) {
    if (monster.eatingTime) {
      // monster got eaten
      return {
        deadTime: constants.MONSTER_DEATH_TIME_SECONDS
      };
    } // player got eaten


    return {
      lost: true
    };
  }

  return vectors[0];
}

function getNewMonsterVector(monster, player, time) {
  if (monster.deadTime > time) {
    return _objectSpread({}, monster, {
      deadTime: monster.deadTime - time
    });
  }

  if (monster.deadTime > 0) {
    return _objectSpread({}, monster, {
      deadTime: 0,
      eatingTime: 0,
      position: monster.startingPosition,
      direction: monster.startingDirection
    });
  }

  var eatingTime = Math.max(0, monster.eatingTime - time);
  var isHome = getIsHome(monster);
  var speed = monster.eatingTime ? constants.MONSTER_SPEED_RETREAT : constants.MONSTER_SPEED_ATTACK;

  try {
    var _getNewPosition = getNewPosition(monster.position, monster.direction, speed, time, !isHome),
        newPosition = _getNewPosition.newPosition,
        collision = _getNewPosition.collision,
        movedDistance = _getNewPosition.movedDistance;

    if (isHome) {
      return getNextMonsterHomePosition(newPosition, monster, player);
    }

    return _objectSpread({}, getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player), {
      eatingTime: eatingTime
    });
  } catch (err) {
    // wrapped or something
    return {};
  }
}

function animateMonster(state, time, player, monster, index) {
  var _getNewMonsterVector = getNewMonsterVector(monster, player, time),
      lost = _getNewMonsterVector.lost,
      monsterVector = _objectWithoutProperties(_getNewMonsterVector, ["lost"]);

  var newMonsters = state.monsters.slice();
  newMonsters[index] = _objectSpread({}, monster, {}, monsterVector);

  if (lost) {
    return _objectSpread({}, state, {
      lost: true
    });
  }

  return _objectSpread({}, state, {
    monsters: newMonsters
  });
}

export function animateMonsters(state, time, player) {
  return state.monsters.reduce(function (lastState, monster, index) {
    return animateMonster(lastState, time, player, monster, index);
  }, state);
}