function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { orderPolarity } from './movement';
import { animateMonsters } from './monster';
import { animatePlayer } from './player';

function collectEatenMonsterScores(newState, oldState) {
  var scoreDelta = newState.monsters.reduce(function (sum, _ref, index) {
    var deadTime = _ref.deadTime;
    return sum + 1000 * ((deadTime > 0 && oldState.monsters[index].deadTime === 0) >> 0);
  }, 0);
  return _objectSpread({}, newState, {
    score: newState.score + scoreDelta
  });
}

export function animate(state) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$time = _ref2.time,
      time = _ref2$time === void 0 ? Date.now() : _ref2$time;

  // get the next game state as a function of time
  var timeSeconds = (time - state.stepTime) / 1000;

  if (state.lost) {
    return state;
  }

  var statePlayerAnimated = animatePlayer(_objectSpread({}, state, {
    stepTime: time
  }), timeSeconds);
  var stateMonstersAnimated = animateMonsters(statePlayerAnimated, timeSeconds, state.player);
  var stateEatenMonsters = collectEatenMonsterScores(stateMonstersAnimated, state);
  return stateEatenMonsters;
}
export function changeDirection(state, _ref3) {
  var direction = _ref3.direction;
  var orderPolarityOld = orderPolarity(state.player.direction);
  var orderPolarityNew = orderPolarity(direction);

  if (orderPolarityOld.plane === orderPolarityNew.plane) {
    return _objectSpread({}, state, {
      player: _objectSpread({}, state.player, {
        direction: direction,
        nextDirection: direction
      })
    });
  }

  return _objectSpread({}, state, {
    player: _objectSpread({}, state.player, {
      nextDirection: direction
    })
  });
}