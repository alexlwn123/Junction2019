import tracks from './tracks';
export function gridDistance(posA, posB) {
  // The Pacman board is a kind of manhattan style map, with constraints
  // due to walls
  return Math.abs(posA[0] - posB[0]) + Math.abs(posA[1] - posB[1]);
}
export function orderPolarity(direction) {
  var order = (direction < 2) >> 0;
  var polarity = Math.pow(-1, 1 - order);
  var plane = direction % 2;
  return {
    order: order,
    polarity: polarity,
    plane: plane
  };
}
export function getNewPosition(position, direction, speed, time) {
  var toNearestPlane = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  var _orderPolarity = orderPolarity(direction),
      order = _orderPolarity.order,
      plane = _orderPolarity.plane,
      polarity = _orderPolarity.polarity;

  var newPosition = position.slice();
  var movedVector = polarity * speed * time;
  var movedDistance = Math.abs(movedVector);
  var nearestOtherPlane = Math.round(newPosition[1 - plane]);

  if (toNearestPlane) {
    newPosition[1 - plane] = nearestOtherPlane;
  }

  newPosition[plane] += movedVector;
  var track = tracks[plane][nearestOtherPlane];
  var trackHit = track.findIndex(function (limits) {
    return position[plane] >= limits[0] && position[plane] <= limits[1] && polarity * newPosition[plane] > polarity * limits[order];
  });
  var collision = false;

  if (trackHit === (track.length - 1) * order && track[trackHit][2]) {
    // wrap
    newPosition[plane] = track[(track.length - 1) * (1 - order)][1 - order];
    movedDistance = speed * time;
  } else if (trackHit > -1) {
    newPosition[plane] = track[trackHit][order];
    movedDistance = Math.abs(position[plane] - track[trackHit][order]);
    collision = true;
  }

  return {
    newPosition: newPosition,
    collision: collision,
    movedDistance: movedDistance
  };
}
export function snapToTrack(plane, order, position, tolerance) {
  var snap = order ? Math.ceil(position[plane]) : Math.floor(position[plane]);

  if (Math.abs(snap - position[plane]) > tolerance) {
    return -1;
  }

  return snap;
}
export function getChangedVector(oldPosition, newPosition, oldDirection, newDirection, movedDistance) {
  var _orderPolarity2 = orderPolarity(oldDirection),
      oldPlane = _orderPolarity2.plane,
      oldOrder = _orderPolarity2.order;

  var trackTo = snapToTrack(oldPlane, oldOrder, newPosition, movedDistance);

  if (trackTo === -1) {
    return null;
  }

  var old0 = oldPosition[oldPlane];
  var new0 = newPosition[oldPlane];
  var movedDistanceBeforeTurn = Math.abs(trackTo - newPosition[oldPlane]);

  if (!(old0 === new0 && movedDistanceBeforeTurn > movedDistance)) {
    var _orderPolarity3 = orderPolarity(newDirection),
        newOrder = _orderPolarity3.order,
        newPlane = _orderPolarity3.plane,
        polarity = _orderPolarity3.polarity;

    var track = tracks[newPlane][trackTo];

    if (!track) {
      return null;
    }

    var trackHit = track.findIndex(function (limits) {
      return newPosition[newPlane] >= limits[0] && newPosition[newPlane] <= limits[1] && (1 - newOrder) * newPosition[newPlane] >= (limits[0] - polarity) * (1 - newOrder) && newOrder * newPosition[newPlane] <= (limits[1] - polarity) * newOrder;
    });

    if (trackHit > -1) {
      var changedVector = newPosition.slice();
      changedVector[oldPlane] = trackTo;
      changedVector[newPlane] += polarity * (movedDistance - movedDistanceBeforeTurn);
      return changedVector;
    }
  }

  return null;
}